name: Sync
on:
  workflow_dispatch: {}
  schedule:
    - cron: "*/10 * * * *" # Runs every 10 minutes

jobs:
  sync:
    name: Sync With Upstream
    runs-on: warp-ubuntu-latest-x64-4x
    steps:
      - uses: actions/create-github-app-token@v1
        id: app-token
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Checkout with GitHub App Token
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}

      - name: Get GitHub App User ID
        id: get-user-id
        run: echo "user-id=$(gh api "/users/${{ steps.app-token.outputs.app-slug }}[bot]" --jq .id)" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
      - run: |
          git config --global user.name '${{ steps.app-token.outputs.app-slug }}[bot]'
          git config --global user.email '${{ steps.get-user-id.outputs.user-id }}+${{ steps.app-token.outputs.app-slug }}[bot]@users.noreply.github.com'

      - name: Sync with upstream repository
        run: |
          # Get the upstream repository URL from GitHub API
          REPO_NAME="${GITHUB_REPOSITORY}"
          UPSTREAM_INFO=$(gh api repos/$REPO_NAME | jq -r '.parent.clone_url // empty')

          if [ -z "$UPSTREAM_INFO" ]; then
            echo "This doesn't appear to be a fork or the API couldn't retrieve the parent repository"
            exit 1
          fi

          echo "Upstream repository: $UPSTREAM_INFO"

          # Check if upstream remote exists, add it if it doesn't
          if ! git remote | grep -q "^upstream$"; then
            git remote add upstream $UPSTREAM_INFO
          else
            git remote set-url upstream $UPSTREAM_INFO
          fi

          # Fetch from upstream and origin
          git fetch upstream
          git fetch origin

          # Store current branch (typically main)
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          echo "Current branch: $CURRENT_BRANCH"

          # Function to sync a branch with conflict resolution
          sync_branch() {
            local branch_name=$1
            echo "Syncing branch: $branch_name"

            # Check if we have upstream commits to sync
            BEHIND_COUNT=$(git rev-list --count HEAD..upstream/$branch_name)
            if [ "$BEHIND_COUNT" -eq 0 ]; then
              echo "Already up to date with upstream/$branch_name (no new commits to sync)"
              return 0
            fi

            echo "Found $BEHIND_COUNT commits to sync from upstream"

            # Improved approach using patch-based strategy to avoid conflicts with workflow files

            # Create a temporary branch to work on
            git checkout -b temp-sync-branch

            # Get list of all .github/workflows files we want to preserve
            WORKFLOW_FILES=$(find .github/workflows -type f -name "*.yml" -o -name "*.yaml" | sort)
            echo "Preserving these workflow files: $WORKFLOW_FILES"

            # Backup these workflow files
            BACKUP_DIR=$(mktemp -d)
            for file in $WORKFLOW_FILES; do
              if [ -f "$file" ]; then
                mkdir -p "$BACKUP_DIR/$(dirname $file)"
                cp "$file" "$BACKUP_DIR/$file"
                echo "Backed up $file"
              fi
            done

            # Now try to merge upstream changes
            echo "Merging upstream changes..."
            if git merge upstream/$branch_name -m "Merge upstream changes"; then
              echo "Merge successful"
            else
              # If there are conflicts in workflow files, resolve by keeping ours
              echo "Merge had conflicts, resolving automatically..."

              # First, check if any workflow files are in conflict
              CONFLICTED_WORKFLOWS=$(git diff --name-only --diff-filter=U | grep "^.github/workflows/")

              if [ -n "$CONFLICTED_WORKFLOWS" ]; then
                echo "Conflicts detected in workflow files: $CONFLICTED_WORKFLOWS"

                # Abort the merge
                git merge --abort

                # Try a different approach with cherry-picking
                echo "Trying cherry-picking approach instead"

                # Reset to our branch
                git reset --hard origin/$branch_name

                # Get list of commits to cherry-pick
                COMMITS_TO_PICK=$(git rev-list --reverse HEAD..upstream/$branch_name)

                for COMMIT in $COMMITS_TO_PICK; do
                  echo "Processing commit: $COMMIT"
                  COMMIT_MSG=$(git log -1 --pretty=format:"%s" $COMMIT)

                  # Check if this commit only modifies workflow files
                  CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r $COMMIT)
                  NON_WORKFLOW_FILES=$(echo "$CHANGED_FILES" | grep -v "^.github/workflows/" || true)

                  if [ -z "$NON_WORKFLOW_FILES" ]; then
                    echo "Commit only changes workflow files, skipping"
                    continue
                  fi

                  # Try cherry-picking
                  if ! git cherry-pick -n $COMMIT; then
                    echo "Cherry-pick had conflicts, resolving..."

                    # Check for conflicted workflow files
                    CONFLICTED_FILES=$(git diff --name-only --diff-filter=U | grep "^.github/workflows/" || true)

                    if [ -n "$CONFLICTED_FILES" ]; then
                      # Keep our version of workflow files
                      for file in $CONFLICTED_FILES; do
                        echo "Keeping our version of $file"
                        git checkout --ours -- "$file"
                        git add "$file"
                      done
                    fi

                    # For any remaining conflicts, manually resolve
                    if [ -n "$(git diff --name-only --diff-filter=U)" ]; then
                      echo "Non-workflow conflicts detected, attempting to resolve..."

                      # Try to resolve by taking ours for deleted files
                      for file in $(git diff --name-only --diff-filter=U); do
                        if [ ! -f "$file" ]; then
                          echo "File was deleted in our version, keeping deletion: $file"
                          git rm "$file"
                        fi
                      done

                      # If there are still conflicts, abort
                      if [ -n "$(git diff --name-only --diff-filter=U)" ]; then
                        echo "Unable to automatically resolve all conflicts, aborting"
                        git cherry-pick --abort
                        continue
                      fi
                    fi

                    # Continue with the cherry-pick
                    git cherry-pick --continue
                  else
                    # Reset any workflow file changes
                    for file in $(git diff --name-only | grep "^.github/workflows/" || true); do
                      echo "Resetting workflow file changes: $file"
                      git checkout HEAD^ -- "$file"
                      git add "$file"
                    done

                    # Commit the changes
                    git commit --amend -m "$COMMIT_MSG" || echo "No changes to commit"
                  fi
                done
              else
                echo "Conflicts in non-workflow files, manual resolution needed"
                git merge --abort
                git reset --hard origin/$branch_name
                echo "Sync failed due to non-workflow file conflicts"
                return 1
              fi
            fi

            # Restore our workflow files
            for file in $WORKFLOW_FILES; do
              if [ -f "$BACKUP_DIR/$file" ]; then
                echo "Restoring $file"
                cp "$BACKUP_DIR/$file" "$file"
                git add "$file"
              elif [ -f "$file" ]; then
                # File exists but wasn't in our backup, meaning it came from upstream
                # We want to keep our state, so remove it
                echo "Removing upstream workflow file: $file"
                git rm -f "$file"
              fi
            done

            # Commit the workflow file restorations if needed
            if ! git diff --staged --quiet; then
              git commit -m "Preserve our workflow files"
            fi

            # Check if we have changes to push
            if git rev-list --count origin/$branch_name..HEAD > 0; then
              # Switch back to original branch and merge changes
              git checkout $branch_name
              git merge --ff-only temp-sync-branch

              # Push changes to origin
              git push origin $branch_name
              echo "Pushed synced changes to origin"
            else
              git checkout $branch_name
              echo "No changes to push"
            fi

            # Clean up
            git branch -D temp-sync-branch
            rm -rf $BACKUP_DIR
          }

          # ----- Sync current branch -----
          sync_branch "$CURRENT_BRANCH"

          echo "Sync complete"
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
